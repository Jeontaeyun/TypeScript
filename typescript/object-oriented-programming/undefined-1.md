# 인터페이스

## 인터페이스 Interface

 타입스크립트에서만 지원하는 특징으로 인터페이스는 **타입이며 컴파일 후에는 사라집니다**.  

추상 클래스는 선언과 구현이 모두 존재하지만 인터페이스는 선언만 존재하며, 멤버 변수와 멤버 메소드를 선언할 수 있지만 접근 제한자는 설정할 수 없습니다. 

자식 인터페이스는 여러 부모 인터페이스를 다중 상속할 수 있습니다. 

```typescript
interface 인터페이스이름 {
    멤버변수이름 : 타입;
    name: string;
    age: number;
    job : string;
}
```

 자식 인터페이스는 extends 키워드를 이용해 부모 인터페이스를 상속해 확장할 수 있으며 클래스와는 다르게 **인터페이스는 여러 부모 인터페이스를 다중 상속할 수 있습니다**.

```typescript
interface <자식 인터페이스 이름> extends <부모 인터페이스...> {
    ... 구현될 내
}
```

 인터페이스를 이용해 클래스를 구현하고 싶을 때는 **implements 키워드**를 이용해 인터페이스를 구현하는 클래스를 작성해야 합니다. 

```typescript
class Stark implements People {
    greating(): void {}
    studying(): void {}
    ...
}
```

### 인터페이스의 역할

 자바스크립트의 객체는 구조를 고정할 수 없고 유연합니다. 하지만, 객체 지향 프로그래밍에서 객체는 유지 보수와 확장 그리고 안정성을 고려해 선언과 동시에 고정할 필요가 있습니다. 

 **인터페이스는 객체의 구조를 고정할 수 있다는 점에서 유용**합니다

### 배열 요소 타입을 객체 리터럴 타입으로 사용

 배열 요소가 객체 리터럴이면 배열 타입을 선언할 때 배열 요소의 타입을 객체 리터럴로 지정해 타입 안정성을 강화할 수 있습니다. 

```typescript
let person : {name: string, city:string}[];
```

 위와 같이 선언하면 해당 배열 안의 데이터는 반드시 {name : "문자열", city: "문자열"}의 형태여야 합니다. 

### 배열 요소 타입과 인터페이스 

 클래스는 객체 리터럴의 타입으로 사용할 수 있습니다. 배열 요소가 객체 리터럴 이라면 배열 타입을 타입을 선언할 때 클래스를 이용할 수 있습니다. 

 인터페이스는 객체 리터럴을 정의하는 타입으로 사용될 수 있습니다. 다음과 같이 사용할 수 있습니다. 

```typescript
interface Person{
    name: string;
    city: string;
}
let person : Person[];
```

### 함수 타입과 인터페이스

 인터페이스의 역할은 다양한데, 클래스의 구조를 정의하기도 하고, 자바스크립트 객체 모양을 정의하기도 하며 **익명 함수에 대한 타입을 정의할 수 있는 기능도 있다**.

```typescript
interface FuncType {
    (data: string, next?: boolean): number;
}
let FuncInterface : FuncType = (data:string, next:boolean) => {
...
}
```

