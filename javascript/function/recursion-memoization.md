# 재귀와 메모이제이션

## 재귀와 메모이제이션 \| Recursion and Memoization

 함수가 자기 자신을 호출하는 것을 재귀라고 하며 그 함수를 재귀 함수라고 합니다. 재귀 함수는 이진 검색 트리, 퀵 솔트 등 다양한 분야에서 사용되니 알아두는 것이 좋습니다. 

{% hint style="info" %}
**분할 정복 알고리즘**

어떤 문제를 한 번에 풀기 힘들 때, 작은 조각으로 쪼개어 푸는 것을 **분할 정복 알고리즘**이라 하며 재귀 함수는 분할 정복 알고리즘의 하나 입니다.
{% endhint %}

 재귀 함수는 컴퓨터의 성능 측면에서는 컴퓨터에게 많은 부담을 주지만, 개발자의 입장에서는 **가독성을 높여줍니다**. 

### 재귀 함수 \| Recursion Function 

 재구 함수란 재귀 호출\(Recursive Call\)을 하는 함수를 말한다. **재귀 호출\(Recursive Call\)이란 함수 내부에서 자기 자신을 다시 호출하는 행위**를 말한다. 

#### 재귀 함수 장점

1. 알고리즘 자체가 재귀적으로 표현하기 자연스러울 때 사용 하면 코드가 간결해져 **가독성**이 높아진다.
2. 변경 가능한 상태\(Mutable-State\)를 제거하여 오류가 발생할 수 있는 가능성을 줄인다. 

#### 재귀 함수 단점

1. 많은 메모리를 사용하기 때문에 **메모리 문제**가 발생할 수 있다.
2. 재귀 호출 마다 스택 메모리에 저장되 재귀가 반복될수록 성**능에 문제가** 발생한다.
3. 분기 처리를 잘못하면 **무한 루프**에 빠지게된다.
4. **스택 오버 플로우**가 발생할 수 있다.

#### 재귀 함수의 대표 예시 \| 피보나치 수열

```javascript
const fibonacci = (number) {
    if(number < 2){
        return number;
    } else {
        // 함수 안에서 자신의 함수를 재귀 호출
        return fibonacci(number-1) + fibonacci(number-2);
    }
}
// 만약 넘버에 3을 넣으면 fibonacci(2) + fibonacci(1)을 반환하고 
// fibonacci(2) = fibonacci(1) + fibonacci(0)이므로
// 1 1 2 3 5 8 식으로 증가하는 피보나치의 3번째 값 2가 나온다.
```

### 메모이제이션 \| Memoization

 **프로그래밍을 할 때 반복되는 결과를 메모리에 저장해서 다음에 같은 결과가 나올 때 빨리 실행하는 빨리 실행하는 프로그래밍 기법**입니다.

메모이제이션은 반복되는 계산이 많을수록 효과가 높아집니다. 특히 반복 작업이 많을 경우에는, 숫자가 커질수록 반복 횟수가 기하급수적으로 늘어납니다. 

{% hint style="info" %}
**메모이제이션**  
  
컴퓨터 프로그램이 동일한 계산을 반복해야 할 때, 이전에 계산한 값을 메모리에 저장함으로 동일한 계산의 반복 수행을 제거하여 프로그램 실행 속도를 빠르게 하는 기술 

메모이제이션을 이용하면 재귀 함수의 성능을 향상 시킬 수 있다.
{% endhint %}

####  피보나치 수열 메모이제이션 활용

```javascript
const fibonacci = (function(){
    // 메모이제이션을 구현하기 위해 save를 넣어줌
    const save = {};
    // 내부 함수에서 외부 함수의 변수를 사용하는 클로저 생
    const fibona = (number) => {
        if(number< 2){
            return number;
        } else {
            // 만약 save에 메모이제이션이 있으면 해당 값을 쓴다. 
            // ||은 디폴트 연산자로 문법적 설탕 중 하나이다.
            // 뒤의 값을 굳이 연산할 필요가 없으니 메모리 상 효율적이다.
            const first = save[number-1] || fibona(number-1);
            const second = save[number-2] || fibona(number-2);
            const result = first + second;
            // save[number]즉, 피보나치의 순서에 해당 값을 기억하도록 함
            save[number] = result;
            return result;
        }
    };
    return fibona;
})();
```

