# 함수의 범위 \| Scope

## 함수의 범위 \| Scope

 자바스크립트르 이해하기 위해서 필수적으로 알아둬야하는 컨셉은 함수의 범위인 Scope이다. Scope란 한 마디로 변수가 존재하는가 아닌가 하는 것에 대한 문제이다.

 예를 들어 다음과 같은 코드를 보자

```javascript
if(true){
    const hello = "hi";
}
console.log(hello); //ERROR
```

 이 코드를 실행하면 에러가 발생할 것이다. 왜냐하면 변수는 큰 곳에서 작은 곳으로는 접근할 수 있는데 그 반대로 접근하는 것은 불가능 하다. 이를 코드로 풀어쓰면 다음과 같다.

```javascript
const h = "hello";                    // Global Scope
function a() {
    console.log(h);
    const b = "b";                    // Local Scope
}
a();
console.log(b);                       // ERROR
```

 즉, 자바스크립트는 내부 함수에서 선언된 값을 외부에서 사용할 수 없지만, 외부에서 선언된\(상위에서 선언된\) 변수는 함수 내부에서 사용할 수 있다. \(단, var 선언자는 함수스코프를 가집니다. 따라서 같은 함수 내라면 어디서든 접근할 수 있는 전역변수가 됩니다.\)

 즉, **스코프는 컨텍스트\(Context\)에서 해당 함수가 있는지에 대한 개념이다.**

{% hint style="info" %}
**전역변수**

프로그래밍을 할 때 전역변수는 되도록이면 없는 것이 좋습니다. 어디서든 접근할 수 있다는 것은 의도하지 않는 버그를 일으킬 수 있기 때문입니다.
{% endhint %}

### 정적 스코프와 동적 스코프

 스코프는 유효범위 , 가시성\(visibility\)라고 불리며 프로그래밍 언어는 정적 스코프 방식과 동적 스코프 방식을 채택할 수 있습니다.

 자바스크립트는 정적 스코프를 채택한 언어로 함수가 선언되었을 때 유효범위를 가집니다.

| 구분 | 설명  |
| :--- | :--- |
| 정적스코프 | 함수가 선언되었을 때를 기준으로 유효 범위를 가지는 스코프 방식 |
| 동적스코프 | 함수가 실행될 때를 기준으로 유효 범위를 가지는 스코프 방식 |

#### 렉시컬 스코핑 \| Lexical scoping

 렉시컬 스코핑은 정적 스코프와 같은 의미로 함수가 실행할 때가 아닌 선언될 때 스코프가 선언된다는 것입니다. 함수를 처음 선언하는 순간, 함수 내부의 변수는 자기 스코프로부터 가장 가까운 곳\(상위 범위에서\)에 있는 변수를 계속 참조하게 됩니다.

아래는 렉시컬 스코핑에 대한 예시입니다.

```javascript
var name = 'stark';                   // Global로 선언
function sayName(){
    console.log(name);                // Global 참조
}

function wrapper(){
    name = 'Taeyun';                  // Global 변수 변경
    sayName();
}
wrapper();    // Taeyun
```

 위의 코드는 wrapper함수 안에서 전역 변수 name을 바꾸기 때문에 sayName\(\)을 실행하면 Taeyun이 나온다. 하지만 name 변수명을 가지는 전역 변수와 지역 변수 모두를 가지면 어떻게 될까?

```javascript
var name = 'stark';                          // Global
function sayName(){
    console.log(name);
}

function wrapper(){
    var name = 'Taeyun';                    // Local
    sayName();
}
wrapper();    // stark
```

 위와 같은 코드일 때는 sayName\(\)이 선언될 때를 기준으로 가까이 있는 글로벌 스코프를 따르기에 위의 값은 지역 변수를 무시한다.

 이와 같이 함수가 실행될 때가 아닌 함수가 선언될 때 스코프가 정해지는 것을 렉시컬 스코핑이라고 한다.

### 전역 스코프와 지역 스코프 

 자바스크립트에서 변수 전역 스코프를 가지는 것은 window객체에 변수를 만드는 것을 말한다. 이렇게 선언된 변수는 모든 범위에서 접근 가능하다. 

{% hint style="info" %}
**스코프 체인 \| Scope Chain**

자바스크립트는 변수의 범위를 호출한 함수의 지역스코프 부터 전역변수가 있는 전역 스코프까지 점차 넓혀가며 찾는다.
{% endhint %}

### 함수 스코프와 블록 스코프

 자바스크립트의 지역 스코프에는 함수 스코프와 블록 스코프 두 종류가 있습니다. 

| 구분  | 설명  |
| :--- | :--- |
| 함수스코프 | 함수 내부에서 변수를 선언하면, 그 변수는 선언한 변수 내부에서만 접근할 수 있습니다.  |
| 블록스코프 | 만약 블록 범위\({}\) 내부에서 변수를 선언하면 그 변수들은 중괄호 블록 내부에서만 접근할 수 있습니다. |

 이때 중요한 것은 ES+부터 생긴 **const, let 선언자는 블록스코프를 지원하지만, var선언자는 블록스코프를 지원하지 않습니다.**

### 네임스페이스**와 모듈 패턴**  

 프로그래밍의 기본 중 하나는 협업입니다. 다양한 사람들이 각자 작업을 한 것을 합할 수 있고, 연결해야할 수 있습니다.

 이런 환경에서 전역 변수가 많다는 것은 치명적인 위험이 될 수 있습니다. 만약  협업자간 서로 같은 변수명을 썼는데 그 변수가 전역 변수였을 때 다른 개발자의 코드에 영향을 줄 수 있습니다.

 자바스크립트 개발자는 이런 상황을 **한 번 함수안에 넣어 지역 변수를 만드는 방식으로 해결\(모듈패턴\)**합니다. 혹은, **객체 안의 속성으로 만들어서 사용합니다\(네임스페이스\)**

#### **네임스페이스**

```javascript
const stark = {
    x: 'local socpe',
    y: 'namespace',
    z(){
        alert(this.x);
    }
}
```

 위와 같이 객체의 속성으로 변수를 선언해 변수가 겹치는 것을 막아주는 방식이 네임스페이스입니다. 대부분의 라이브러리가 각자 고유의 네임스페이스가 있는 것을 기억하면 이해하기 쉽습니다.

#### 모듈 패턴 \| 즉시 호출 함수 표현식 \(IIFE\)

 함 수 안에 넣어서 지역 변수를 만드는 방식으로 해결할 수도 있습니다.

```javascript
const newScope = (function(){
    var x = 'local scope';            // Private
    var y = 'modulePattern';          // Private
    var z = function() {              // Public
        alert(x);
    }
    return {z: z};
})();
```

 이 때 , 함수는 z만 반환하므로 newScope에서는 z에 대해서만 접근할 수 있습니다. 자동적으로 x와, y의 값이 비공개 처리됩니다. 

 비공개 변수가 없는 자바스크립트에 비공개 변수의 기능을 만들어 주기에 해당 패턴은 익혀두어야 합니다.

{% hint style="info" %}
**Java의 비공개 변수**

자바에서는 클래스 내부에 private, pulic등의 값을 통해서 비공개 변수를 선언할 수 있습니다. 다만, 자바스크립트에서는 해당 기능이 없어 위와 같이 IIFE 패턴으로 비공개 변수를 만들어 주어야 합니다.
{% endhint %}

